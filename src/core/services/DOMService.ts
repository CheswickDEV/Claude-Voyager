import { LoggerService } from "./LoggerService";export type ClaudeSelectorKey =  | "appRoot"  | "chatContainer"  | "messageGroup"  | "messageAuthor"  | "messageContent"  | "sidebar"  | "conversationItem"  | "inputArea";export type SelectorRegistry = Record<ClaudeSelectorKey, string>;const selectorRegistry: SelectorRegistry = {  appRoot: "#root",  chatContainer: "main",  messageGroup: "[data-testid='chat-message']",  messageAuthor: "[data-testid='chat-message-author']",  messageContent: "[data-testid='chat-message-content']",  sidebar: "aside",  conversationItem: "[data-testid='conversation-item']",  inputArea: "[contenteditable='true']"};export type ObserverHandle = {  disconnect: () => void;};export class DOMService {  private static instance: DOMService | null = null;  private logger = LoggerService.getInstance();  static getInstance(): DOMService {    if (!DOMService.instance) {      DOMService.instance = new DOMService();    }    return DOMService.instance;  }  /**   * Returns a snapshot of the current selector registry.   */  getSelectors(): SelectorRegistry {    return { ...selectorRegistry };  }  /**   * Updates a selector key at runtime to handle UI changes.   */  setSelector(key: ClaudeSelectorKey, value: string): void {    selectorRegistry[key] = value;    this.logger.info("Selector updated", { key, value });  }  /**   * Safely query a single element using a registered selector.   */  query<T extends Element>(key: ClaudeSelectorKey, root: ParentNode = document): T | null {    const selector = selectorRegistry[key];    if (!selector) {      this.logger.warn("Selector missing", { key });      return null;    }    return root.querySelector(selector) as T | null;  }  /**   * Safely query multiple elements using a registered selector.   */  queryAll<T extends Element>(key: ClaudeSelectorKey, root: ParentNode = document): T[] {    const selector = selectorRegistry[key];    if (!selector) {      this.logger.warn("Selector missing", { key });      return [];    }    return Array.from(root.querySelectorAll(selector)) as T[];  }  /**   * Waits for an element to appear, retrying until timeout.   */  async waitForElement<T extends Element>(    key: ClaudeSelectorKey,    options: { timeoutMs?: number; intervalMs?: number } = {}  ): Promise<T | null> {    const { timeoutMs = 4000, intervalMs = 250 } = options;    const start = Date.now();    return new Promise((resolve) => {      const attempt = () => {        const element = this.query<T>(key);        if (element) {          resolve(element);          return;        }        if (Date.now() - start >= timeoutMs) {          this.logger.warn("waitForElement timed out", { key });          resolve(null);          return;        }        window.setTimeout(attempt, intervalMs);      };      attempt();    });  }  /**   * Observes DOM mutations for a given root element.   */  observe(    root: Node,    callback: MutationCallback,    options: MutationObserverInit = { childList: true, subtree: true }  ): ObserverHandle {    const observer = new MutationObserver(callback);    observer.observe(root, options);    return {      disconnect: () => observer.disconnect()    };  }}